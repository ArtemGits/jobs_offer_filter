I can suggest two solutions for that tech task. Firstly we can improve the current algorithm with ets tables, and concurrency batch handling database data. For example, we can store the jobs offers in ets tables per continent, and store those tables in the genserver’s state, but for a real big genserver’s state, i think, we need to store results of data processing in the database, just periodically delete old records by some other genservers in background. And when new job offers come to the server we can immediately filter that data in the background, for example with Elixir.Task and when receiving results - modify ets tables in the main genserver’s state.



Secondly, we can create two new tables in the database. The user offers an application table that contains results and a finish flag for data processing, and a result table. That application table and result table are in one to many relationships. Application has many results. So, when a user trying to get job offers in the database creates an application record and receives application_id  to the client back and data processing starts in the background. Periodically the client will fetch the data processing results until the application’s finish flag turns on. With that solution, we give our clients the ability to consume small pieces of data during data processing without waiting. Of Course in that solution, we can use previous suggestions with additional genservers and ets tables for vertical scaling.
